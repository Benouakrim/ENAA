// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// =====================
// ENUMS
// =====================

enum Role {
  CLIENT
  VENDOR
  ADMIN
}

enum PriceRange {
  BUDGET    // 0-500€
  STANDARD  // 500-1500€
  PREMIUM   // 1500-4000€
  LUXE      // 4000€+
}

enum ServiceCategory {
  VENUE
  CATERER
  PHOTOGRAPHER
  DJ
  DECORATOR
  FLORIST
  VIDEOGRAPHER
  MAKEUP
  PLANNER
  PATISSERIE
  TRANSPORT
  ANIMATOR
}

enum BookingStatus {
  PENDING      // Awaiting vendor confirmation
  CONFIRMED    // Vendor confirmed
  PAID         // Customer paid
  IN_PROGRESS  // Service being delivered
  COMPLETED    // Service delivered
  CANCELLED    // Booking cancelled
  REFUNDED     // Payment refunded
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

// =====================
// USER & VENDOR MODELS
// =====================

model User {
  id          String   @id // Maps to Clerk user ID
  email       String   @unique
  role        Role     @default(CLIENT)
  
  // Profile Information (synced from Clerk + wizard)
  firstName   String?
  lastName    String?
  phone       String?
  country     String?
  city        String?
  birthday    DateTime?
  avatarUrl   String?
  
  // Onboarding status
  onboardingCompleted  Boolean  @default(false)
  
  // Preferences from wizard (acts as filter presets)
  preferredEventTypes   String[]
  preferredBudget       PriceRange?
  preferredGuestCount   String?
  preferredStyles       String[]
  preferredCategories   ServiceCategory[]
  preferredRegion       String?
  wizardCompleted       Boolean  @default(false)
  
  // Relations
  vendorProfile       VendorProfile?
  cart                Cart?
  bookings            Booking[]
  reviews             Review[]
  favorites           Favorite[]
  conversationsAsUser1 Conversation[] @relation("User1Conversations")
  conversationsAsUser2 Conversation[] @relation("User2Conversations")
  messages            Message[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("users")
}

model VendorProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  companyName String
  description String?  @db.Text
  logo        String?
  coverImage  String?
  city        String
  region      String?
  address     String?
  verified    Boolean  @default(false)
  featured    Boolean  @default(false)
  
  // Business info
  yearFounded     Int?
  teamSize        String?
  travelRadius    Int?        // in km
  responseTime    String?     // "< 1h", "< 24h", etc.
  
  // Stats
  totalBookings   Int      @default(0)
  totalRevenue    Float    @default(0)
  rating          Float    @default(0)
  reviewCount     Int      @default(0)
  
  // Contact & Social
  phone        String?
  email        String?
  website      String?
  instagram    String?
  facebook     String?
  
  // Relations
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  services     ServiceListing[]
  packs        Pack[]
  availability VendorAvailability[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("vendor_profiles")
}

// =====================
// SERVICE LISTING (Unified Model)
// =====================

model ServiceListing {
  id          String          @id @default(cuid())
  vendorId    String
  
  // Basic Info
  title       String
  description String          @db.Text
  category    ServiceCategory
  
  // Location
  city        String
  region      String
  address     String?
  
  // Pricing
  priceType   String          // "fixed", "per_person", "per_hour", "per_day", "quote"
  price       Float           // Base price
  priceMax    Float?          // For range pricing
  priceRange  PriceRange
  
  // Category-specific metadata (JSON for flexibility)
  metadata    Json?           // Stores category-specific fields
  
  // Common attributes
  eventTypes  String[]        // Mariage, Anniversaire, etc.
  styles      String[]        // Bohème, Moderne, etc.
  amenities   String[]        // Features/inclusions
  images      String[]
  
  // Capacity (for venues, caterers)
  minCapacity Int?
  maxCapacity Int?
  
  // Status & Visibility
  active      Boolean  @default(true)
  featured    Boolean  @default(false)
  verified    Boolean  @default(false)
  
  // Stats
  rating      Float    @default(0)
  reviewCount Int      @default(0)
  viewCount   Int      @default(0)
  bookingCount Int     @default(0)
  
  // Relations
  vendor       VendorProfile    @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  availability ServiceAvailability[]
  reviews      Review[]
  cartItems    CartItem[]
  bookingItems BookingItem[]
  packItems    PackItem[]
  favorites    Favorite[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([category])
  @@index([city])
  @@index([region])
  @@index([priceRange])
  @@index([featured])
  @@map("service_listings")
}

// =====================
// AVAILABILITY MODELS
// =====================

model ServiceAvailability {
  id         String   @id @default(cuid())
  serviceId  String
  date       DateTime @db.Date
  available  Boolean  @default(true)
  
  // Time slots (optional, for hourly services)
  startTime  String?  // "09:00"
  endTime    String?  // "18:00"
  
  // Special pricing for specific dates
  specialPrice Float?
  
  service ServiceListing @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  
  @@unique([serviceId, date, startTime])
  @@index([date])
  @@map("service_availability")
}

model VendorAvailability {
  id       String   @id @default(cuid())
  vendorId String
  date     DateTime @db.Date
  available Boolean @default(true)
  note     String?
  
  vendor VendorProfile @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  
  @@unique([vendorId, date])
  @@map("vendor_availability")
}

// =====================
// PACKS & DEALS
// =====================

model Pack {
  id          String   @id @default(cuid())
  vendorId    String
  name        String
  description String   @db.Text
  
  // Pricing
  originalPrice  Float    // Sum of individual services
  discountedPrice Float   // Pack price
  discountPercent Float   // Calculated discount %
  
  // Validity
  active      Boolean  @default(true)
  validFrom   DateTime?
  validUntil  DateTime?
  
  // Stats
  bookingCount Int     @default(0)
  
  images      String[]
  
  // Relations
  vendor   VendorProfile @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  items    PackItem[]
  cartItems CartItem[]
  bookingItems BookingItem[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("packs")
}

model PackItem {
  id        String @id @default(cuid())
  packId    String
  serviceId String
  
  pack    Pack           @relation(fields: [packId], references: [id], onDelete: Cascade)
  service ServiceListing @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  
  @@unique([packId, serviceId])
  @@map("pack_items")
}

model Deal {
  id          String   @id @default(cuid())
  
  // Can apply to specific service, category, or vendor-wide
  serviceId   String?
  vendorId    String?
  category    ServiceCategory?
  
  name        String
  description String?
  code        String?   @unique // Promo code
  
  // Discount
  discountType  String   // "percentage" or "fixed"
  discountValue Float    // 10 for 10% or 10€
  
  // Limits
  minPurchase   Float?
  maxDiscount   Float?
  usageLimit    Int?
  usedCount     Int      @default(0)
  
  // Validity
  active      Boolean  @default(true)
  validFrom   DateTime
  validUntil  DateTime
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("deals")
}

// =====================
// CART SYSTEM
// =====================

model Cart {
  id       String @id @default(cuid())
  userId   String @unique
  
  // Event details for the cart
  eventDate    DateTime?
  eventType    String?
  guestCount   Int?
  
  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  items CartItem[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("carts")
}

model CartItem {
  id        String @id @default(cuid())
  cartId    String
  
  // Either a service or a pack
  serviceId String?
  packId    String?
  
  // Selected options
  selectedDate DateTime?
  quantity     Int       @default(1)
  notes        String?
  
  // Price at time of adding (for consistency)
  unitPrice    Float
  
  cart    Cart            @relation(fields: [cartId], references: [id], onDelete: Cascade)
  service ServiceListing? @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  pack    Pack?           @relation(fields: [packId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("cart_items")
}

// =====================
// BOOKING & PAYMENT
// =====================

model Booking {
  id          String        @id @default(cuid())
  userId      String
  
  // Event details
  eventDate   DateTime
  eventType   String?
  eventCity   String?
  guestCount  Int?
  notes       String?       @db.Text
  
  // Status
  status      BookingStatus @default(PENDING)
  
  // Pricing
  subtotal      Float
  discountAmount Float      @default(0)
  serviceFee    Float       // Platform commission
  total         Float
  
  // Contact info
  contactName   String?
  contactPhone  String?
  contactEmail  String?
  
  // Relations
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  items        BookingItem[]
  transactions Transaction[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([status])
  @@index([eventDate])
  @@map("bookings")
}

model BookingItem {
  id         String @id @default(cuid())
  bookingId  String
  
  // Either a service or a pack
  serviceId  String?
  packId     String?
  
  // Snapshot of service info at booking time
  serviceName  String
  vendorName   String
  category     ServiceCategory
  
  // Pricing
  unitPrice    Float
  quantity     Int    @default(1)
  total        Float
  
  // Status for this specific item
  status       BookingStatus @default(PENDING)
  vendorNotes  String?
  
  booking  Booking         @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  service  ServiceListing? @relation(fields: [serviceId], references: [id])
  pack     Pack?           @relation(fields: [packId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("booking_items")
}

model Transaction {
  id          String        @id @default(cuid())
  bookingId   String
  
  // Payment details
  amount        Float
  currency      String      @default("EUR")
  status        PaymentStatus @default(PENDING)
  
  // Stripe integration
  stripePaymentIntentId String? @unique
  stripeChargeId        String?
  
  // Commission tracking
  platformFee     Float      // What we keep
  vendorPayout    Float      // What vendor gets
  
  // Refund info
  refundedAmount  Float?
  refundReason    String?
  
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("transactions")
}

// =====================
// MESSAGING SYSTEM
// =====================

model Conversation {
  id       String @id @default(cuid())
  user1Id  String  // Usually the client
  user2Id  String  // Usually the vendor
  
  // Context (optional link to booking/service)
  bookingId  String?
  serviceId  String?
  
  // Last message preview
  lastMessageAt    DateTime?
  lastMessageText  String?
  
  user1    User      @relation("User1Conversations", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("User2Conversations", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([user1Id, user2Id])
  @@map("conversations")
}

model Message {
  id             String      @id @default(cuid())
  conversationId String
  senderId       String
  
  type           MessageType @default(TEXT)
  content        String      @db.Text
  
  // File attachments
  fileUrl        String?
  fileName       String?
  
  // Read status
  read           Boolean     @default(false)
  readAt         DateTime?
  
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@index([conversationId])
  @@index([senderId])
  @@map("messages")
}

// =====================
// REVIEWS & FAVORITES
// =====================

model Review {
  id         String @id @default(cuid())
  serviceId  String
  userId     String
  bookingId  String?
  
  rating     Int      // 1-5
  title      String?
  comment    String?  @db.Text
  
  // Vendor response
  vendorResponse   String? @db.Text
  vendorRespondedAt DateTime?
  
  // Moderation
  approved   Boolean  @default(true)
  
  service ServiceListing @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([serviceId, userId])
  @@map("reviews")
}

model Favorite {
  id        String @id @default(cuid())
  userId    String
  serviceId String
  
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  service ServiceListing @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@unique([userId, serviceId])
  @@map("favorites")
}
